<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System V11: Bright Holograms & Moon</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; cursor: none; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }

        .hud-bottom {
            position: absolute; bottom: 30px; width: 100%;
            display: flex; justify-content: center;
        }
        .hud-panel {
            background: rgba(5, 10, 15, 0.95);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 40px; padding: 15px 40px;
            backdrop-filter: blur(20px); color: #fff;
            display: flex; gap: 30px; align-items: center;
            box-shadow: 0 0 50px rgba(0, 200, 255, 0.15);
        }
        .stat-label { font-size: 10px; color: #888; letter-spacing: 2px; text-transform: uppercase; }
        .stat-value { font-size: 16px; font-weight: 700; color: #fff; min-width: 120px; text-shadow: 0 0 10px rgba(255,255,255,0.8); }

        #side-panel {
            position: absolute; right: -500px; top: 50%; 
            transform: translateY(-50%);
            width: 350px;
            background: rgba(0, 0, 0, 0.9);
            border-left: 4px solid #00d2ff;
            padding: 40px;
            color: white;
            transition: right 0.6s cubic-bezier(0.22, 1, 0.36, 1);
        }
        #side-panel.active { right: 0; }
        
        .planet-title { font-size: 48px; font-weight: 300; margin: 0 0 10px 0; letter-spacing: 6px; color: #00d2ff; text-shadow: 0 0 25px rgba(0, 210, 255, 0.6); }
        .planet-desc { font-size: 14px; color: #bbb; line-height: 1.6; margin-bottom: 25px; }
        .data-row { display: flex; justify-content: space-between; border-bottom: 1px solid #333; padding: 12px 0; }
        .data-key { color: #666; font-size: 11px; text-transform: uppercase; letter-spacing: 1px; }
        .data-val { font-family: 'Courier New', monospace; font-size: 16px; color: #fff; text-shadow: 0 0 5px rgba(255,255,255,0.3); }

        #finger-cursor {
            position: absolute; width: 60px; height: 60px;
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            display: flex; align-items: center; justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            transition: border-color 0.2s, background-color 0.2s, transform 0.1s;
            box-shadow: 0 0 15px rgba(255,255,255,0.2);
        }
        #finger-cursor.locked { 
            border-color: #00ffaa; 
            background: rgba(0, 255, 170, 0.2); 
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 0 25px rgba(0, 255, 170, 0.4);
        }
        
        .progress-ring { position: absolute; width: 100%; height: 100%; transform: rotate(-90deg); }
        .progress-ring__circle {
            transition: stroke-dashoffset 0.1s linear;
            transform-origin: 50% 50%;
            stroke: #00ffaa; 
        }

        #input_video { position: absolute; opacity: 0; pointer-events: none; z-index: -1; }
        
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 999;
            transition: opacity 0.5s ease-out;
        }
    </style>
</head>
<body>

    <div id="loader">
        <div style="color: white; letter-spacing: 8px; font-weight: 300; font-size: 24px;">INITIALIZING OPTICS</div>
    </div>

    <div id="ui-layer">
        <div id="finger-cursor">
            <svg class="progress-ring" width="60" height="60">
                <circle class="progress-ring__circle" stroke-width="4" fill="transparent" r="26" cx="30" cy="30" stroke-dasharray="163" stroke-dashoffset="163" />
            </svg>
        </div>

        <div class="hud-bottom">
            <div class="hud-panel" id="main-hud">
                <div>
                    <div class="stat-label">Mode</div>
                    <div class="stat-value" id="mode-val">SYSTEM VIEW</div>
                </div>
                <div style="width: 1px; height: 30px; background: rgba(255,255,255,0.2);"></div>
                <div>
                    <div class="stat-label">Target Lock</div>
                    <div class="stat-value" id="target-val" style="color: #00ffaa;">SCANNING...</div>
                </div>
            </div>
        </div>

        <div id="side-panel">
            <h1 class="planet-title" id="p-name">EARTH</h1>
            <p class="planet-desc" id="p-desc">Description here.</p>
            <div class="data-row"><span class="data-key">Diameter</span><span class="data-val" id="p-diam">0</span></div>
            <div class="data-row"><span class="data-key">Temp</span><span class="data-val" id="p-temp">0</span></div>
            <div class="data-row"><span class="data-key">Gravity</span><span class="data-val" id="p-grav">0</span></div>
            <div class="data-row"><span class="data-key">Satellites</span><span class="data-val" id="p-moons">0</span></div>
            <div style="margin-top: 30px; font-size: 11px; color: #555; letter-spacing: 1px;">PINCH TO ZOOM • MOVE AWAY TO EXIT</div>
        </div>
    </div>

    <video id="input_video" playsinline></video>

    <script type="x-shader/x-vertex" id="planetVertex">
        uniform float uTime;
        uniform float uScale;
        attribute float aRandom;
        attribute float aSize;
        
        attribute float aIsMoon;
        attribute float aOrbitRad;
        attribute float aOrbitSpeed;
        attribute float aOrbitOffset;

        varying float vAlpha;
        varying vec3 vColorVariation;

        void main() {
            vec3 basePos = position;

            // SATELLITE ORBIT LOGIC
            if(aIsMoon > 0.5) {
                float angle = aOrbitOffset + uTime * aOrbitSpeed * 0.2; 
                basePos.x = cos(angle) * aOrbitRad;
                basePos.z = sin(angle) * aOrbitRad;
                // Keep y local to create sphere shape of moon, don't flatten orbit
                // The vertex position is relative to the moon center now
            }

            vec3 pos = basePos * uScale;
            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_Position = projectionMatrix * mvPosition;

            float twinkle = sin(uTime * 5.0 + aRandom * 50.0);
            twinkle = smoothstep(-0.2, 1.0, twinkle); // Sharp twinkle

            // Moons are solid, Planet is large
            float sizeMult = (aIsMoon > 0.5) ? 450.0 : 700.0; 
            gl_PointSize = (aSize * (0.8 + 0.4 * twinkle)) * (sizeMult / -mvPosition.z);
            
            vAlpha = 0.8 + 0.2 * twinkle; // Very opaque
            
            // Moons are pure white/bright
            vColorVariation = (aIsMoon > 0.5) ? vec3(1.2, 1.2, 1.2) : vec3(1.0, 1.0 - aRandom * 0.2, 1.0 + aRandom * 0.2); 
        }
    </script>
    <script type="x-shader/x-fragment" id="planetFragment">
        uniform vec3 uColor;
        varying float vAlpha;
        varying vec3 vColorVariation;
        void main() {
            float r = length(gl_PointCoord - vec2(0.5));
            if (r > 0.5) discard;
            
            // Harder core for brightness
            float glow = 1.0 - (r * 2.0);
            glow = pow(glow, 1.2); 

            vec3 baseColor = uColor * vColorVariation;
            
            // BRIGHTNESS BOOST: Multiplier increased to 4.5
            vec3 finalColor = baseColor * 4.5; 
            
            // Hot white center
            finalColor += vec3(1.0) * pow(glow, 4.0);

            gl_FragColor = vec4(finalColor, vAlpha * glow);
        }
    </script>

    <script type="x-shader/x-vertex" id="sunVertex">
        uniform float uTime;
        attribute float aRandom;
        varying float vAlpha;
        varying vec3 vPos;
        void main() {
            vPos = position; 
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_Position = projectionMatrix * mvPosition;
            gl_PointSize = (15.0 + aRandom * 8.0) * (300.0 / -mvPosition.z);
            vAlpha = 0.95;
        }
    </script>
    <script type="x-shader/x-fragment" id="sunFragment">
        uniform vec3 uColorCore;
        uniform vec3 uColorRim;
        uniform float uTime;
        varying float vAlpha;
        varying vec3 vPos;
        float random (in vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123); }
        float noise (in vec2 st) {
            vec2 i = floor(st); vec2 f = fract(st);
            float a = random(i); float b = random(i + vec2(1.0, 0.0));
            float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }
        void main() {
            float r = length(gl_PointCoord - vec2(0.5));
            if (r > 0.5) discard;
            float glow = 1.0 - (r * 2.0);
            glow = pow(glow, 1.8);
            float n = noise(vPos.xy * 0.1 + uTime * 0.3);
            vec3 surfColor = mix(uColorCore, uColorRim, n);
            vec3 finalColor = surfColor * 3.0 + vec3(1.0, 1.0, 0.8) * pow(glow, 3.0);
            gl_FragColor = vec4(finalColor, vAlpha * glow);
        }
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils@0.6/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        // --- DATA ---
        const PLANET_DATA = [
            { name: "MERCURY", color: 0xAAAAAA, particleColor: new THREE.Color("#e0e0e0"), dist: 100, size: 4.5,  moonCount: 0, desc: "The smallest planet.", realDia: "4,879 km", temp: "167°C", grav: "3.7 m/s²" },
            { name: "VENUS",   color: 0xE3BB76, particleColor: new THREE.Color("#ffdd88"), dist: 160, size: 6.0,  moonCount: 0, desc: "Hottest planet.", realDia: "12,104 km", temp: "464°C", grav: "8.87 m/s²" },
            { name: "EARTH",   color: 0x2233FF, particleColor: new THREE.Color("#00aaff"), dist: 220, size: 6.5,  moonCount: 1, desc: "Our home.", realDia: "12,742 km", temp: "15°C", grav: "9.8 m/s²" },
            { name: "MARS",    color: 0xFF4500, particleColor: new THREE.Color("#ff5533"), dist: 280, size: 5.0,  moonCount: 2, desc: "The Red Planet.", realDia: "6,779 km", temp: "-65°C", grav: "3.71 m/s²" },
            { name: "JUPITER", color: 0xD9A066, particleColor: new THREE.Color("#ffaa55"), dist: 400, size: 14.0, moonCount: 4, desc: "Gas Giant.", realDia: "139,820 km", temp: "-110°C", grav: "24.79 m/s²" },
            { name: "SATURN",  color: 0xF4D03F, particleColor: new THREE.Color("#ffee88"), dist: 520, size: 12.0, moonCount: 6, rings: true, desc: "Ringed Jewel.", realDia: "116,460 km", temp: "-140°C", grav: "10.44 m/s²" },
            { name: "URANUS",  color: 0x4FD0E7, particleColor: new THREE.Color("#66ffff"), dist: 640, size: 9.0,  moonCount: 4, rings: true, desc: "Ice Giant.", realDia: "50,724 km", temp: "-195°C", grav: "8.69 m/s²" },
            { name: "NEPTUNE", color: 0x2E67F8, particleColor: new THREE.Color("#4466ff"), dist: 760, size: 8.5,  moonCount: 3, desc: "Windy World.", realDia: "49,244 km", temp: "-200°C", grav: "11.15 m/s²" }
        ];

        const STATE = {
            mode: 'SOLAR', targetIndex: -1, hoverIndex: -1, selectionProgress: 0, particleScale: 1.0, particleRotY: 0, lastModeChange: 0
        };
        const cursorSmoothing = { x: 0.5, y: 0.5 };
        const smoothingFactor = 0.15;

        // --- THREE.JS ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0002);
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 10000);
        camera.position.set(0, 300, 850);
        camera.lookAt(0, 0, 0);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        scene.add(new THREE.PointLight(0xffaa00, 4.0, 2000));

        // --- SOLAR GROUP ---
        const solarGroup = new THREE.Group();
        solarGroup.position.x = -100; 
        scene.add(solarGroup);

        // SUN
        const sunGeo = new THREE.SphereGeometry(45, 64, 64); 
        const sunMat = new THREE.ShaderMaterial({
            uniforms: { uTime: { value: 0 }, uColorCore: { value: new THREE.Color("#ffcc00") }, uColorRim: { value: new THREE.Color("#ff4400") } },
            vertexShader: document.getElementById('sunVertex').textContent,
            fragmentShader: document.getElementById('sunFragment').textContent,
            transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
        });
        const sunParticles = new THREE.Points(sunGeo, sunMat);
        solarGroup.add(sunParticles);

        // PLANETS
        const planetMeshes = [];
        const hitMeshes = [];
        PLANET_DATA.forEach((p, i) => {
            const container = new THREE.Group();
            const mesh = new THREE.Mesh(new THREE.SphereGeometry(p.size, 32, 32), new THREE.MeshStandardMaterial({ color: p.color, roughness: 0.6, metalness: 0.2 }));
            if(p.rings) {
                const r = new THREE.Mesh(new THREE.RingGeometry(p.size*1.4, p.size*2.2, 64), new THREE.MeshBasicMaterial({ color: 0xcccccc, side: THREE.DoubleSide, transparent: true, opacity: 0.5 }));
                r.rotation.x = Math.PI/2.2; mesh.add(r);
            }
            container.add(mesh);
            const hitGeo = new THREE.SphereGeometry(p.size * 5.0, 16, 16); 
            const hitMesh = new THREE.Mesh(hitGeo, new THREE.MeshBasicMaterial({ visible: false }));
            hitMesh.userData = { id: i, name: p.name };
            container.add(hitMesh);
            hitMeshes.push(hitMesh);
            const angleStep = (Math.PI * 1.2) / (PLANET_DATA.length - 1);
            const angle = (i * angleStep) - (Math.PI * 0.6);
            container.position.set(p.dist * Math.sin(angle), 0, p.dist * Math.cos(angle) * 0.3);
            solarGroup.add(container);
            planetMeshes.push(container);
        });

        scene.add(new THREE.Points(new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(new Float32Array(10000 * 3).map(()=>(Math.random()-0.5)*4000), 3)), new THREE.PointsMaterial({color:0xffffff, size:1.5, transparent:true, opacity:0.5})));

        // --- HOLOGRAPHIC PARTICLES (High Res) ---
        const particleCount = 120000; 
        const pGeo = new THREE.BufferGeometry();
        const pPos = new Float32Array(particleCount * 3);
        const pRnd = new Float32Array(particleCount);
        const pSize = new Float32Array(particleCount);
        const pIsMoon = new Float32Array(particleCount);
        const pOrbitRad = new Float32Array(particleCount);
        const pOrbitSpeed = new Float32Array(particleCount);
        const pOrbitOffset = new Float32Array(particleCount);

        for(let i=0; i<particleCount; i++) { pPos[i*3]=0; pRnd[i]=Math.random(); pSize[i]=1.0; pIsMoon[i]=0; }
        
        // Attributes
        pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        pGeo.setAttribute('aRandom', new THREE.BufferAttribute(pRnd, 1));
        pGeo.setAttribute('aSize', new THREE.BufferAttribute(pSize, 1));
        pGeo.setAttribute('aIsMoon', new THREE.BufferAttribute(pIsMoon, 1));
        pGeo.setAttribute('aOrbitRad', new THREE.BufferAttribute(pOrbitRad, 1));
        pGeo.setAttribute('aOrbitSpeed', new THREE.BufferAttribute(pOrbitSpeed, 1));
        pGeo.setAttribute('aOrbitOffset', new THREE.BufferAttribute(pOrbitOffset, 1));

        const pMat = new THREE.ShaderMaterial({
            uniforms: { uTime: { value: 0 }, uColor: { value: new THREE.Color("#00d2ff") }, uScale: { value: 0.0 } },
            vertexShader: document.getElementById('planetVertex').textContent,
            fragmentShader: document.getElementById('planetFragment').textContent,
            transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
        });
        const particleSystem = new THREE.Points(pGeo, pMat);
        scene.add(particleSystem);
        particleSystem.visible = false;

        function generatePlanetParticles(index) {
            const data = PLANET_DATA[index];
            const hasRings = data.rings;
            const baseRad = 80.0;
            const moonCount = data.moonCount;
            
            let particlesUsed = 0;

            // 1. GENERATE MOONS
            if(moonCount > 0) {
                // Determine particles per moon. Earth needs dense moon.
                const particlesPerMoon = (index === 2) ? 1500 : 800; // Index 2 is Earth

                for(let m=0; m<moonCount; m++) {
                    // Orbit Logic
                    const orbitRad = baseRad * 2.2 + (m * 40.0); // Spaced orbits
                    const orbitSpeed = (m % 2 === 0 ? 1 : -1) * (0.3 + Math.random() * 0.2);
                    const orbitOffset = Math.random() * Math.PI * 2;
                    
                    // Moon Size
                    const moonRad = (index === 2) ? 12.0 : 6.0; // Earth moon is big

                    for(let i=0; i<particlesPerMoon; i++) {
                        const idx = particlesUsed + i;
                        
                        // Create Sphere for Moon
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2 * Math.random() - 1);
                        
                        // We store the moon's LOCAL coordinates in position
                        // The vertex shader handles the orbital translation
                        pPos[idx*3] = moonRad * Math.sin(phi) * Math.cos(theta);
                        pPos[idx*3+1] = moonRad * Math.sin(phi) * Math.sin(theta);
                        pPos[idx*3+2] = moonRad * Math.cos(phi);

                        pIsMoon[idx] = 1.0;
                        pOrbitRad[idx] = orbitRad;
                        pOrbitSpeed[idx] = orbitSpeed;
                        pOrbitOffset[idx] = orbitOffset;
                    }
                    particlesUsed += particlesPerMoon;
                }
            }

            // 2. GENERATE PLANET
            for(let i=particlesUsed; i<particleCount; i++) {
                let x,y,z,s;
                const r = Math.random();
                pIsMoon[i] = 0.0; 

                if(hasRings && r < 0.45) { // Rings
                    const angle = Math.random() * Math.PI * 2;
                    const dist = (baseRad * 1.3) + Math.random() * (baseRad * 1.2);
                    x = Math.cos(angle)*dist; z = Math.sin(angle)*dist; y = (Math.random()-0.5)*3.0;
                    s = Math.random() * 2.5;
                } else { // Sphere
                    const theta = Math.random()*Math.PI*2;
                    const phi = Math.acos(2*Math.random()-1);
                    x=baseRad*Math.sin(phi)*Math.cos(theta); y=baseRad*Math.sin(phi)*Math.sin(theta); z=baseRad*Math.cos(phi);
                    s = Math.random() * 3.5; 
                }
                const tilt = 0.3;
                const ty = y; y = y*Math.cos(tilt)-z*Math.sin(tilt); z = ty*Math.sin(tilt)+z*Math.cos(tilt);
                pPos[i*3] = x; pPos[i*3+1] = y; pPos[i*3+2] = z;
            }

            pGeo.attributes.position.needsUpdate = true;
            pGeo.attributes.aIsMoon.needsUpdate = true;
            pGeo.attributes.aOrbitRad.needsUpdate = true;
            pGeo.attributes.aOrbitSpeed.needsUpdate = true;
            pGeo.attributes.aOrbitOffset.needsUpdate = true;

            pMat.uniforms.uColor.value = data.particleColor;
        }

        // --- LOGIC ---
        const raycaster = new THREE.Raycaster(); const pointer = new THREE.Vector2(); let smoothedPinch = 0; raycaster.params.Points.threshold = 10;
        const videoElement = document.getElementById('input_video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        const cursor = document.getElementById('finger-cursor'); const ringCircle = document.querySelector('.progress-ring__circle'); const hudTarget = document.getElementById('target-val');

        hands.onResults(results => {
            document.getElementById('loader').style.opacity = 0;
            if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                cursor.style.opacity = 1; const lm = results.multiHandLandmarks[0]; const index = lm[8]; const thumb = lm[4];
                cursorSmoothing.x += (index.x - cursorSmoothing.x) * smoothingFactor; cursorSmoothing.y += (index.y - cursorSmoothing.y) * smoothingFactor;
                cursor.style.left = (1 - cursorSmoothing.x) * window.innerWidth + 'px'; cursor.style.top = cursorSmoothing.y * window.innerHeight + 'px';
                pointer.x = ((1 - cursorSmoothing.x) * 2) - 1; pointer.y = -(cursorSmoothing.y * 2) + 1;
                const now = Date.now();

                if(STATE.mode === 'SOLAR') {
                    checkIntersection(index);
                } else if(STATE.mode === 'DETAIL') {
                    if(now - STATE.lastModeChange < 2000) return;
                    const pinch = Math.hypot(thumb.x - index.x, thumb.y - index.y);
                    smoothedPinch += (pinch - smoothedPinch) * 0.1;
                    STATE.particleScale = 1.0 + (smoothedPinch * 6.0);
                    STATE.particleRotY += (cursorSmoothing.x - 0.5) * 0.05;
                    if(Math.hypot(pointer.x, pointer.y) > 0.7) exitDetailView();
                }
            } else {
                cursor.style.opacity = 0;
                if(STATE.mode === 'SOLAR') {
                    if(STATE.selectionProgress > 0) { STATE.selectionProgress -= 0.02; applyProgressVisuals(); } else { resetSelection(); }
                }
            }
        });

        const cameraUtils = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 640, height: 480 }); cameraUtils.start();

        function checkIntersection(rawFingerTip) {
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(hitMeshes);
            if (intersects.length > 0) {
                const idx = intersects[0].object.userData.id;
                if (STATE.hoverIndex !== idx) { STATE.hoverIndex = idx; hudTarget.innerText = intersects[0].object.userData.name; cursor.classList.add('locked'); } 
                STATE.selectionProgress += 0.04; 
            } else {
                STATE.selectionProgress -= 0.005; 
                if(STATE.selectionProgress <= 0) resetSelection();
            }
            STATE.selectionProgress = Math.max(0, Math.min(1, STATE.selectionProgress));
            applyProgressVisuals();
            ringCircle.style.strokeDashoffset = 163 - (STATE.selectionProgress * 163);
            if (STATE.selectionProgress >= 1.0 && STATE.mode === 'SOLAR') enterDetailView(STATE.hoverIndex);
        }

        function applyProgressVisuals() {
            const p = STATE.selectionProgress; sunParticles.scale.setScalar(1.0 - p);
            planetMeshes.forEach((mesh, i) => { if(i === STATE.hoverIndex) mesh.scale.setScalar(1.0 + (p * 1.5)); else mesh.scale.setScalar(Math.max(0, 1.0 - p)); });
        }
        function resetSelection() {
            STATE.hoverIndex = -1; STATE.selectionProgress = 0; hudTarget.innerText = "SCANNING..."; cursor.classList.remove('locked'); ringCircle.style.strokeDashoffset = 163;
            sunParticles.scale.setScalar(1); planetMeshes.forEach(mesh => mesh.scale.setScalar(1));
        }
        function enterDetailView(index) {
            STATE.mode = 'DETAIL'; STATE.lastModeChange = Date.now(); STATE.targetIndex = index; document.getElementById('mode-val').innerText = "HOLOGRAPHIC"; cursor.classList.remove('locked'); 
            generatePlanetParticles(index); particleSystem.visible = true; STATE.particleScale = 0;
            gsap.to(STATE, { particleScale: 1.0, duration: 1.5, ease: "back.out(1.0)" });
            solarGroup.visible = false;
            const d = PLANET_DATA[index]; document.getElementById('p-name').innerText = d.name; document.getElementById('p-name').style.color = "#" + d.particleColor.getHexString(); document.getElementById('side-panel').classList.add('active');
            document.getElementById('p-diam').innerText = d.realDia; document.getElementById('p-temp').innerText = d.temp; document.getElementById('p-grav').innerText = d.grav;
            document.getElementById('p-moons').innerText = d.moonCount > 0 ? d.moonCount : "0";
        }
        function exitDetailView() {
            STATE.mode = 'SOLAR'; STATE.lastModeChange = Date.now(); document.getElementById('mode-val').innerText = "SYSTEM VIEW"; document.getElementById('side-panel').classList.remove('active');
            gsap.to(STATE, { particleScale: 0, duration: 0.5, onComplete: () => { particleSystem.visible = false; solarGroup.visible = true; resetSelection(); }});
        }
        function animate() {
            requestAnimationFrame(animate); const time = performance.now() * 0.001;
            if(STATE.mode === 'SOLAR') { solarGroup.rotation.y = Math.sin(time * 0.02) * 0.05; sunParticles.rotation.y -= 0.005; sunMat.uniforms.uTime.value = time; }
            else { pMat.uniforms.uTime.value = time; pMat.uniforms.uScale.value += (STATE.particleScale - pMat.uniforms.uScale.value) * 0.1; particleSystem.rotation.y += (STATE.particleRotY - particleSystem.rotation.y) * 0.1; }
            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        animate();
    </script>
</body>
</html>
