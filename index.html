<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System V3: Enhanced UX</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; cursor: none; }
        
        /* UI LAYOUT */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }

        /* HUD BOTTOM */
        .hud-bottom {
            position: absolute; bottom: 30px; width: 100%;
            display: flex; justify-content: center;
        }
        .hud-panel {
            background: rgba(10, 15, 20, 0.85);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 40px; padding: 15px 40px;
            backdrop-filter: blur(10px); color: #fff;
            display: flex; gap: 30px; align-items: center;
            box-shadow: 0 0 30px rgba(0, 150, 255, 0.2);
            transition: opacity 0.5s;
        }
        .stat-label { font-size: 10px; color: #888; letter-spacing: 2px; text-transform: uppercase; }
        .stat-value { font-size: 16px; font-weight: 700; color: #fff; min-width: 120px; }

        /* SIDE ANNOTATION PANEL */
        #side-panel {
            position: absolute; right: -400px; top: 50%; 
            transform: translateY(-50%);
            width: 300px;
            background: rgba(0, 0, 0, 0.85);
            border-left: 2px solid #00d2ff;
            padding: 30px;
            color: white;
            transition: right 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #side-panel.active { right: 0; }
        
        .planet-title { font-size: 32px; font-weight: 300; margin: 0 0 10px 0; letter-spacing: 4px; color: #00d2ff; }
        .planet-desc { font-size: 14px; color: #ccc; line-height: 1.6; margin-bottom: 20px; }
        .data-row { display: flex; justify-content: space-between; border-bottom: 1px solid #333; padding: 10px 0; }
        .data-key { color: #888; font-size: 12px; text-transform: uppercase; }
        .data-val { font-family: monospace; font-size: 14px; color: #fff; }

        /* CURSOR */
        #finger-cursor {
            position: absolute; width: 40px; height: 40px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            display: flex; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.2);
        }
        
        .progress-ring { position: absolute; width: 100%; height: 100%; transform: rotate(-90deg); }
        .progress-ring__circle {
            transition: stroke-dashoffset 0.1s linear;
            transform-origin: 50% 50%;
        }

        #input_video { position: absolute; opacity: 0; pointer-events: none; z-index: -1; }
        
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 999;
            transition: opacity 0.5s ease-out;
        }
    </style>
</head>
<body>

    <div id="loader">
        <div style="color: white; letter-spacing: 5px;">CALIBRATING SENSORS</div>
    </div>

    <div id="ui-layer">
        <div id="finger-cursor">
            <svg class="progress-ring" width="40" height="40">
                <circle class="progress-ring__circle" stroke="#00d2ff" stroke-width="3" fill="transparent" r="17" cx="20" cy="20" stroke-dasharray="106" stroke-dashoffset="106" />
            </svg>
        </div>

        <div class="hud-bottom">
            <div class="hud-panel" id="main-hud">
                <div>
                    <div class="stat-label">System Mode</div>
                    <div class="stat-value" id="mode-val">ORBITAL</div>
                </div>
                <div style="width: 1px; height: 30px; background: #333;"></div>
                <div>
                    <div class="stat-label">Target</div>
                    <div class="stat-value" id="target-val" style="color: #00d2ff;">NONE</div>
                </div>
            </div>
        </div>

        <div id="side-panel">
            <h1 class="planet-title" id="p-name">EARTH</h1>
            <p class="planet-desc" id="p-desc">Description here.</p>
            <div class="data-row"><span class="data-key">Diameter</span><span class="data-val" id="p-diam">0</span></div>
            <div class="data-row"><span class="data-key">Temp</span><span class="data-val" id="p-temp">0</span></div>
            <div class="data-row"><span class="data-key">Gravity</span><span class="data-val" id="p-grav">0</span></div>
            <div style="margin-top: 20px; font-size: 10px; color: #666;">PINCH TO ZOOM • INDEX TO ROTATE</div>
        </div>
    </div>

    <video id="input_video" playsinline></video>

    <script type="x-shader/x-vertex" id="vertexshader">
        uniform float uTime;
        uniform float uScale;
        attribute float aRandom;
        attribute float aSize;
        varying float vAlpha;
        varying vec3 vColorVariation;
        void main() {
            vec3 pos = position * uScale;
            float dist = length(pos.xy);
            pos.z += sin(dist * 0.2 - uTime * 1.5) * 0.2;
            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_Position = projectionMatrix * mvPosition;
            float twinkle = sin(uTime * 3.0 + aRandom * 25.0);
            twinkle = smoothstep(-1.0, 1.0, twinkle);
            gl_PointSize = (aSize * (0.6 + 0.6 * twinkle)) * (300.0 / -mvPosition.z);
            vAlpha = 0.3 + 0.7 * twinkle;
            vColorVariation = vec3(1.0, 1.0 - aRandom * 0.2, 1.0 + aRandom * 0.2); 
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform vec3 uColor;
        varying float vAlpha;
        varying vec3 vColorVariation;
        void main() {
            float r = length(gl_PointCoord - vec2(0.5));
            if (r > 0.5) discard;
            float glow = 1.0 - (r * 2.0);
            glow = pow(glow, 2.5); 
            vec3 finalColor = uColor * vColorVariation;
            finalColor += vec3(0.8) * pow(glow, 5.0); 
            gl_FragColor = vec4(finalColor, vAlpha * glow);
        }
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils@0.6/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        // --- UPDATED CONFIGURATION ---
        // Distances increased significantly. Size Adjusted for visibility.
        const PLANET_DATA = [
            { name: "MERCURY", color: 0xAAAAAA, particleColor: new THREE.Color("#aaaaaa"), dist: 35, size: 1.2,  desc: "The swift planet.", realDia: "4,879 km", temp: "167°C", grav: "3.7 m/s²" },
            { name: "VENUS",   color: 0xE3BB76, particleColor: new THREE.Color("#ffcc66"), dist: 50, size: 1.8,  desc: "Thick atmosphere.", realDia: "12,104 km", temp: "464°C", grav: "8.87 m/s²" },
            { name: "EARTH",   color: 0x2233FF, particleColor: new THREE.Color("#0088ff"), dist: 65, size: 2.0,  desc: "The Blue Marble.", realDia: "12,742 km", temp: "15°C", grav: "9.8 m/s²" },
            { name: "MARS",    color: 0xFF4500, particleColor: new THREE.Color("#ff4422"), dist: 80, size: 1.5,  desc: "The Red Planet.", realDia: "6,779 km", temp: "-65°C", grav: "3.71 m/s²" },
            { name: "JUPITER", color: 0xD9A066, particleColor: new THREE.Color("#d9a066"), dist: 110, size: 5.0,  desc: "Gas Giant.", realDia: "139,820 km", temp: "-110°C", grav: "24.79 m/s²" },
            { name: "SATURN",  color: 0xF4D03F, particleColor: new THREE.Color("#f4d03f"), dist: 140, size: 4.5,  rings: true, desc: "Ringed Jewel.", realDia: "116,460 km", temp: "-140°C", grav: "10.44 m/s²" },
            { name: "URANUS",  color: 0x4FD0E7, particleColor: new THREE.Color("#4fd0e7"), dist: 170, size: 3.0, rings: true, desc: "Ice Giant.", realDia: "50,724 km", temp: "-195°C", grav: "8.69 m/s²" },
            { name: "NEPTUNE", color: 0x2E67F8, particleColor: new THREE.Color("#3366ff"), dist: 200, size: 2.8, desc: "Windy World.", realDia: "49,244 km", temp: "-200°C", grav: "11.15 m/s²" }
        ];

        const STATE = {
            mode: 'SOLAR',
            targetIndex: -1,
            hoverIndex: -1,
            hoverStartTime: 0,
            particleScale: 1.0,
            particleRotY: 0
        };

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.001); // Lighter fog so distant planets are visible
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 3000);
        // Pulled camera WAY back to fit the new distances
        camera.position.set(0, 100, 260); 
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- LIGHTING (Enhanced for Visibility) ---
        // Increased Ambient light so back of planets are visible (not black)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); 
        scene.add(ambientLight);

        // Stronger Sun light
        const sunLight = new THREE.PointLight(0xffffff, 3.0, 600);
        scene.add(sunLight);

        // --- OBJECTS ---
        const solarGroup = new THREE.Group();
        scene.add(solarGroup);

        // Sun
        const sunMesh = new THREE.Mesh(new THREE.SphereGeometry(15, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffdd00 }));
        const spriteMat = new THREE.SpriteMaterial({ map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/glow.png'), color: 0xffaa00, transparent: true, blending: THREE.AdditiveBlending });
        const sunGlow = new THREE.Sprite(spriteMat);
        sunGlow.scale.set(100, 100, 1.0);
        sunMesh.add(sunGlow);
        solarGroup.add(sunMesh);

        // Planets & Hitboxes
        const planetMeshes = [];
        const hitMeshes = []; // Invisible meshes for easier clicking

        PLANET_DATA.forEach((p, i) => {
            const container = new THREE.Group();

            // 1. VISUAL MESH
            const mesh = new THREE.Mesh(
                new THREE.SphereGeometry(p.size, 32, 32),
                new THREE.MeshStandardMaterial({ color: p.color, roughness: 0.6, metalness: 0.1 })
            );
            
            // Rings
            if(p.rings) {
                const r = new THREE.Mesh(new THREE.RingGeometry(p.size*1.4, p.size*2.2, 32), new THREE.MeshBasicMaterial({ color: 0xcccccc, side: THREE.DoubleSide, transparent: true, opacity: 0.5 }));
                r.rotation.x = Math.PI/2.2; mesh.add(r);
            }
            container.add(mesh);

            // 2. HIT MESH (Invisible, Larger)
            // This is the "Magnet" for your finger
            const hitGeo = new THREE.SphereGeometry(p.size * 3.5, 16, 16); 
            const hitMat = new THREE.MeshBasicMaterial({ visible: false }); 
            const hitMesh = new THREE.Mesh(hitGeo, hitMat);
            hitMesh.userData = { id: i, name: p.name };
            container.add(hitMesh);
            hitMeshes.push(hitMesh);

            // Positioning (Arc spread)
            const angle = (i / (PLANET_DATA.length - 1)) * Math.PI - (Math.PI / 2); 
            container.position.set(p.dist * Math.sin(angle), 0, p.dist * Math.cos(angle) * 0.4);
            
            solarGroup.add(container);
            planetMeshes.push(container); // Store container to animate
        });

        // Background Stars
        const stars = new THREE.Points(
            new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(new Float32Array(6000 * 3).map(()=>(Math.random()-0.5)*1000), 3)),
            new THREE.PointsMaterial({color:0xffffff, size:0.7, transparent:true, opacity:0.8})
        );
        scene.add(stars);

        // Visual Ray Line (Laser)
        const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0)]);
        const lineMat = new THREE.LineBasicMaterial({ color: 0x00d2ff, transparent: true, opacity: 0 });
        const rayLine = new THREE.Line(lineGeo, lineMat);
        scene.add(rayLine);

        // --- PARTICLE SYSTEM (Detail View) ---
        const particleCount = 40000;
        const pGeo = new THREE.BufferGeometry();
        const pPos = new Float32Array(particleCount * 3);
        const pRnd = new Float32Array(particleCount);
        const pSize = new Float32Array(particleCount);
        // Fill buffers...
        for(let i=0; i<particleCount; i++) { pPos[i*3]=0; pRnd[i]=Math.random(); pSize[i]=1.0; }
        pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        pGeo.setAttribute('aRandom', new THREE.BufferAttribute(pRnd, 1));
        pGeo.setAttribute('aSize', new THREE.BufferAttribute(pSize, 1));

        const pMat = new THREE.ShaderMaterial({
            uniforms: { uTime: { value: 0 }, uColor: { value: new THREE.Color("#00d2ff") }, uScale: { value: 0.0 } },
            vertexShader: document.getElementById('vertexshader').textContent,
            fragmentShader: document.getElementById('fragmentshader').textContent,
            transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
        });
        const particleSystem = new THREE.Points(pGeo, pMat);
        scene.add(particleSystem);
        particleSystem.visible = false;

        function generatePlanetParticles(index) {
            const data = PLANET_DATA[index];
            const hasRings = data.rings;
            for(let i=0; i<particleCount; i++) {
                let x,y,z,s;
                const r = Math.random();
                if(hasRings && r < 0.4) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 12 + Math.random() * 8;
                    x = Math.cos(angle)*dist; z = Math.sin(angle)*dist; y = (Math.random()-0.5)*0.5;
                    s = Math.random() * 2.0;
                } else {
                    const theta = Math.random()*Math.PI*2;
                    const phi = Math.acos(2*Math.random()-1);
                    const rad = 7.0; 
                    x=rad*Math.sin(phi)*Math.cos(theta); y=rad*Math.sin(phi)*Math.sin(theta); z=rad*Math.cos(phi);
                    s = Math.random() * 3.0;
                }
                const tilt = 0.4;
                const ty = y; y = y*Math.cos(tilt)-z*Math.sin(tilt); z = ty*Math.sin(tilt)+z*Math.cos(tilt);
                pPos[i*3] = x; pPos[i*3+1] = y; pPos[i*3+2] = z;
            }
            pGeo.attributes.position.needsUpdate = true;
            pMat.uniforms.uColor.value = data.particleColor;
        }

        // --- INPUT & LOGIC ---
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let smoothedPinch = 0;
        
        // Raycaster Threshold settings
        raycaster.params.Points.threshold = 1; 

        const videoElement = document.getElementById('input_video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

        const cursor = document.getElementById('finger-cursor');
        const ringCircle = document.querySelector('.progress-ring__circle');
        const hudTarget = document.getElementById('target-val');

        hands.onResults(results => {
            document.getElementById('loader').style.opacity = 0;
            if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                cursor.style.opacity = 1;
                const lm = results.multiHandLandmarks[0];
                const index = lm[8];
                const thumb = lm[4];
                
                // Cursor visual
                const cx = (1 - index.x) * window.innerWidth;
                const cy = index.y * window.innerHeight;
                cursor.style.left = cx + 'px'; cursor.style.top = cy + 'px';

                // Map 2D hand to 3D Ray
                // Flip X for mirror feel
                pointer.x = ((1 - index.x) * 2) - 1; 
                pointer.y = -(index.y * 2) + 1;

                if(STATE.mode === 'SOLAR') {
                    checkIntersection(index); // Pass index landmark for line drawing
                } else {
                    // Detail Interaction
                    rayLine.material.opacity = 0; // Hide line
                    const pinch = Math.hypot(thumb.x - index.x, thumb.y - index.y);
                    smoothedPinch += (pinch - smoothedPinch) * 0.1;
                    if(smoothedPinch > 0.05) STATE.particleScale = 0.5 + (smoothedPinch * 4.0);
                    const dx = (index.x - 0.5);
                    STATE.particleRotY += dx * 0.05;
                    if(smoothedPinch < 0.03) exitDetailView();
                }
            } else {
                cursor.style.opacity = 0;
                rayLine.material.opacity = 0;
            }
        });

        const cameraUtils = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 640, height: 480 });
        cameraUtils.start();

        function checkIntersection(indexFingerTip) {
            raycaster.setFromCamera(pointer, camera);
            
            // RAYCAST AGAINST HITBOXES (Not visual meshes)
            const intersects = raycaster.intersectObjects(hitMeshes);

            if (intersects.length > 0) {
                const hitObj = intersects[0].object;
                const idx = hitObj.userData.id;
                
                // Draw Line logic
                const vec = new THREE.Vector3();
                vec.set( (1 - indexFingerTip.x) * 2 - 1, -indexFingerTip.y * 2 + 1, 0.5 );
                vec.unproject( camera );
                vec.sub( camera.position ).normalize();
                const distance = - camera.position.z / vec.z;
                const pos = new THREE.Vector3();
                pos.copy( camera.position ).add( vec.multiplyScalar( distance ) );
                
                // Update Line
                const positions = rayLine.geometry.attributes.position.array;
                // Start at camera "near plane" roughly where finger is
                positions[0] = pos.x; positions[1] = pos.y; positions[2] = pos.z - 50; 
                // End at Planet
                const pPos = planetMeshes[idx].position;
                positions[3] = pPos.x; positions[4] = pPos.y; positions[5] = pPos.z;
                rayLine.geometry.attributes.position.needsUpdate = true;
                rayLine.material.opacity = 0.4;

                if (STATE.hoverIndex !== idx) {
                    STATE.hoverIndex = idx;
                    STATE.hoverStartTime = Date.now();
                    hudTarget.innerText = hitObj.userData.name;
                    hudTarget.style.color = "#00d2ff";
                    // Scale effect on the visual mesh inside the container
                    gsap.to(planetMeshes[idx].children[0].scale, {x:1.3, y:1.3, z:1.3, duration:0.3});
                } else {
                    const elapsed = Date.now() - STATE.hoverStartTime;
                    // Circle Progress (106 is circumference)
                    const progress = Math.min(elapsed / 800, 1.0); // 800ms dwell (faster)
                    ringCircle.style.strokeDashoffset = 106 - (progress * 106);
                    
                    if (progress >= 1.0) enterDetailView(idx);
                }
            } else {
                // Reset Previous
                if(STATE.hoverIndex !== -1) {
                    gsap.to(planetMeshes[STATE.hoverIndex].children[0].scale, {x:1.0, y:1.0, z:1.0, duration:0.3});
                }
                STATE.hoverIndex = -1;
                hudTarget.innerText = "NONE";
                hudTarget.style.color = "#fff";
                ringCircle.style.strokeDashoffset = 106;
                rayLine.material.opacity = 0;
            }
        }

        function enterDetailView(index) {
            if(STATE.mode === 'DETAIL') return; // Debounce
            STATE.mode = 'DETAIL';
            STATE.targetIndex = index;
            document.getElementById('mode-val').innerText = "HOLOGRAPHIC";

            generatePlanetParticles(index);
            particleSystem.visible = true;
            STATE.particleScale = 0;
            gsap.to(STATE, { particleScale: 1.0, duration: 1.5, ease: "back.out(1.7)" });

            // Hide Solar System
            gsap.to(solarGroup.position, { z: 200, opacity: 0, duration: 1 });
            gsap.to(solarGroup.scale, { x: 0, y: 0, z: 0, duration: 1 });
            
            // Side Panel
            const d = PLANET_DATA[index];
            document.getElementById('p-name').innerText = d.name;
            document.getElementById('side-panel').classList.add('active');
            
            // Update Data
            document.getElementById('p-diam').innerText = d.realDia;
            document.getElementById('p-temp').innerText = d.temp;
            document.getElementById('p-grav').innerText = d.grav;
        }

        function exitDetailView() {
            if(STATE.mode === 'SOLAR') return;
            STATE.mode = 'SOLAR';
            document.getElementById('mode-val').innerText = "ORBITAL";
            document.getElementById('side-panel').classList.remove('active');

            gsap.to(STATE, { particleScale: 0, duration: 0.5, onComplete: () => { particleSystem.visible = false; } });

            // Show Solar System
            gsap.to(solarGroup.position, { z: 0, duration: 1.5, ease: "power2.out" });
            gsap.to(solarGroup.scale, { x: 1, y: 1, z: 1, duration: 1.5 });
            
            // Reset Hover to prevent instant re-trigger
            STATE.hoverIndex = -1;
            STATE.hoverStartTime = 0;
            rayLine.material.opacity = 0;
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;

            if(STATE.mode === 'SOLAR') {
                solarGroup.rotation.y = Math.sin(time * 0.05) * 0.05;
                planetMeshes.forEach(p => p.rotation.y += 0.005);
            } else {
                pMat.uniforms.uTime.value = time;
                pMat.uniforms.uScale.value += (STATE.particleScale - pMat.uniforms.uScale.value) * 0.1;
                particleSystem.rotation.y += (STATE.particleRotY - particleSystem.rotation.y) * 0.1;
            }

            stars.rotation.y -= 0.0001;
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
